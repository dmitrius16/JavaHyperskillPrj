Let's imagine we have list of friends:
    
    List<String> friends = Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");

I. Iterating through a list: (only functional style, imperative style not considered)

    1)  anonymous class approach

        friends.forEach(new Consumer<String>() {
            public void accept(final String name) {
                System.out.println(name);
            }
        });

    2) lambda approach
        
        friends.forEach((final String name) -> System.out.println(name));
        
        Java compiler can infer type:

        friends.forEach(name -> System.out.println(name)); //here compiler doesn't make name as final

        and more short using method reference:

        friends.forEach(System.out::println)

II. Transforming a List: 
    Create a new collection of uppercase names

    friends.stream()
           .map(name -> name.toUpperCase())
           .forEach(name -> System.out.println(name + " "));

    use Method reference:

    friends.stream()
           .map(String::toUpperCase)
           .forEach(System.out::println);

    Output: BRIAN NATE NEAL RAJU SARA SCOTT

    Create a new collections of names length

    friends.stream()
           .map(name -> name.length())
           .forEach(count -> System.out.println(count + " "))

III. Finding Elements
    Find names that start with ... for example 'N'

    final List<String> startWithN = 
        friends.stream()
               .filter(name -> name.startWith("N"))
               .collect(Collectors.toList());

    More flex solution if we want search not only "N" symbol:

    public static Predicate<String> checkIfStartWith(final String letter) {
        return name -> name.startWith(letter);
    }

    final long countFriendStartN = 
        friends.stream()
               .filter(checkIfStartWith("N")).count();

    final long countFriendStartB = 
        friends.stream()
               .filter(checkIfStartWith("B")).count();

    So far we use "public static" for checkIfStartWith but it's not good
    idea. We have to narrow the function's scope to where it's needed.
    We can do that using a Function interface.

    final Function<String, Predicate<String>> startWithLetter = 
        (String letter) -> {
            Predicate<String> checkStarts = (String name) -> name.startWith(letter);
            return checkStarts;
        };
    
    Or more shorter:
    final Function<String, Predicate<String>> startWithLetter = 
        (String letter) -> (String name) -> name.startWith(letter);

    even more shorter:
    final Function<String, Predicate<String>> startWithLetter = 
        letter->name->name.startWith(letter); 


    using predicate:

    final long countFriendsStartN = 
        friends.stream()
               .filter(startWithLetter("N")).count();

    final long countFriendsStartB = 
        friends.stream()
               .filter(startWithLetter("B")).count();

IV. Picking element:
    public static pickName(final List<String> names, final String startingLetter) {
        final Optional<String> foundNames = 
            names.stream()
                 .filter(name -> name.startWith(startingLetter))
                 .findFirst();

        System.out.println(String.format("A name starting with %s: %s),
            startingLetter, foundNames.orElse("No name found"));
    }

    we can ask Optional to run block of code:
    foundName.ifPresent(name -> System.out.printLn("Hello " + name));

V. Reducing a Collection to a Single Value

    Let's read over the values in the frinds collection of names and determine the total
    number of characters:

        System.out.println("Total number of characters in all names: " + 
            friends.stream()
                   .mapToInt(name -> name.length())
                   .sum());

        Output: Total number of characters in all names: 26

    method sum() being the special case of the more general reduce operation.

    reduce() is used to compare two elements against each other and pass along the result
    for further comparison with the remaining elements in the collection. 
    
    Example find longest name:
        
        final Optional<String> aLongName = 
            friends.stream()
                   .reduce((name1, name2) ->
                        name1.length() >= name2.length() ? name1: name2);
        aLingName.ifPresent(name ->
            System.out.println(String.format("A longest name: %s", name)));

        Output: A longest name: Brian.

    reduce() - takes two parameters, name1 and name2 and returns one of them based on the length.

    we can pass to reduce default value, example:
    final String steveOrLonger =
        friends.stream()
               .reduce("Steve", (name1, name2) -> 
                    name1.length() >= name2.length() ? name1 : name2);
    
    if any name was longer than given base, it would get picked up, otherwise the function would return
    the base value.

VI Joining elements:
    Bad approach
    for(String name : friends) {
        System.out.print(name + ", ");
    }
    System.println();
    
    Output:
    Brian, Nate, Neal, Raju, Sara, Scott,

    for fix comma problem at the end of output we can write:

    for(int i = 0; i < friends.size() - 1; i++) {
        System.out.println(friends[i]);
    }
    if (frinds.size() > 0) {
        System.out.println(friends.get(friends.size() - 1));
    }

    Output:
    Brian, Nate, Neal, Raju, Sara, Scott

    Correct approach:
    ------------------------------------------------
    System.out.println(String.join(", ", friends));
    ------------------------------------------------

    We could also use the reduce() method for concatenate elements into a string,
    but that would require some extra effort on our part. There is collect method, which is another 
    form of reduce that can help us collect values into a target destination.

    System.out.println(
        friends.stream()
               .map(String::toUpperCase)
               .collect(joining(", ")));
    
    Output:
        BRIAN, NATE, NEAL, RAJU, SARA, SCOTT
        




    