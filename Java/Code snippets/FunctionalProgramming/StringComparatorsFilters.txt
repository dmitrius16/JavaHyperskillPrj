I. Iterating a String

    final String str = "w00t";

    str.chars()
       .forEach(ch -> System.out.println(ch));

    or more concise:

    str.chars()
       .forEach(System.out::println);

    Here output is digit!!!

    output:

    119
    48
    48
    116

    if we want output characters we have to make casting

    public class IterateString {
        private static void printChar(int aChar) {
            System.out.println((char)aChar);
        }
        public static void main(String[] args) {
            final String str = "w00t";

            str.chars()
               .forEach(IterateString::printChar);
        }
    }

    Or if we want to process characters and not int from the start:

    str.chars()
       .mapToObj(ch -> Characters.valueOf(ch))
       .forEach(System.out::println);

    Filter sequence

    str.chars()
       .filter(Character::isDigit)
       .forEach(IterateString::printChar);

II. Implementing the ComparatorInterface

    public class Person {
        private final String name;
        private final int age;

        public Person(final String theName, final int theAge) {
            name = theName;
            age = theAge;
        }
        public String getName() {reuturn name;}
        public int getAge() {return age;}

        public int ageDifference(final Person other) {
            return age - other.age;
        }

        public String toString() {
            return String.format("%s - %d", name, age);
        }
    }

    Create list of person:

    final List<Person> people = Arrays.asList(
        new Person("John", 20),
        new Person("Sara", 21),
        new Person("Jane", 21),
        new Person("Greg", 35),
    )


    Sort the people in the list in ascending order by age

    List<Person> ascendingAge = 
        people.stream()
              .sorted((person1, person2) -> person1.ageDifference(person2))
              .collect(toList());

    Here we can reduce code to:

        people.stream()
              .sorted(Person::ageDifference)

    Here compiler take two parameters and make first one ageDifference method and second the parameter.

    For reverse sorting we can make following:

        people.stream()
              .sorted((person1, person2) -> person2.ageDifference(person1))
              .collect(toList());

        but here we can't use function reference !!! see page 63

    Using comparator:

        Comparator<Person> compareAscending = 
            (person1, person2) -> person1.ageDifference(person2);

        Compare<Person> compareDescending = compareAscending.reversed();

        printPeople("Sorted in ascending order by age: ", 
            people.stream()
                .sorted(compareAscending)
                .collect(toList()));

        printPeople("Sotrted in descending order by age: ",
            people.stream()
                .sorted(compareDescending)
                .collect(toList()));

    Pick up min and max elements:

        people.stream()
            .max(Person::ageDifference)     // here we can place min with Comparator interface.
            .ifPresent(eldest -> System.out.println("Eldest: " + eldest));
            
III. Mutltiple and Fluent Comparison
        
    First approach:
        people.stream()
              .sorted((person1, person2) -> person1.getName().compareTo(person2.getName()));
              
    But we can do better tahnks to convenience usint them.
    
        final Function<Person, String> byName = person -> person.getName();
        people.stream()
              .sorted(comparing(byName))

    We can take this fluency further to make multiple comparisons.
    Here we sort people in ascending order by both age and name:
    
        final Function<Person, Integer> byAge = person -> person.getAge();
        final Function<Person, String> byTheirName = person -> person.getName();
        
        List<Person> people = people.stream()
                                    .sorted(comparing(byAge).thenComparing(byTheirName))
                                    .collect(toList()));
                                    
    
IV. Using the collect Method and the Collectors Class.
    
    Here version that uses mutability and forEach()
    
        List<Person> olderThan20 = new ArrayList<>();
        people.stream()
              .filter(person -> person.getAge() > 20)
              .forEach(person -> olderThan20.add(person));
        
        System.out.println("People older than 20: " + olderThan20)
        
        Output:
        People older than 20: [Sara - 21, Jane - 21, Greg - 35]
        
    There are a few issues. First, the operation of adding an element into the target collection
    is pretty low level - imperative rather declarative. If we decide to make the iteration concurent, 
    we immediately have to deal with thread-safety concerns.
    
    The collect() method takes a stream of elements and collects or gathers them into a result container.
    To do that, the method needs to know three things:
        
        * How to make a result container(for example, using the ArrayList::new method)
        
        * How to add a single element to a result container (for example, using the ArrayList::add method)
        
        * How to merge one result to a result container (for example, using ArrayList::addAll method)
        
            List<Person> olderThan20 = 
                people.stream()
                      .filter(person -> person.getAge() > 20)
                      .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
            System.out.println("People older than 20: " + olderThan20);
            
    Another variant that uses Collectors.toList()
        
            List<Person> olderThan20 = 
                people.stream()
                      .filter(person->person.getAge() > 20)
                      .collect(Collectors.toList());
                      
    There are several methods on the Collectors to perform various collect or accumulate operations.
    For example: toList(), toSet(), toMap(). We can also join multiple combine operations using methods like:
    mapping(), collectingAndThen(), minBy(), maxBy(), and groupingBy().
        
        Example with groupingBy:
            
            Map<Integer, List<Person>> peopleByAge = 
                people.stream()
                      .collect(Collectors.groupingBy(Person::getAge));
            System.out.println("Groped by age: " + peopleByAge);
            
        Output:
            Grouped by age: {35-[Greg - 35], 20=[John - 20], 21=[Sara - 21, Jane - 21]}
                      

    Continuing with the previous example, instead of creating a map of all Person objects by age,
    let's get only people's name, ordered by age.
        
            Map<Integer, List<String>> nameOfPeopleByAge = 
                people.stream()
                      .collect(groupingBy(Person::getAge, mapping(Person::getName, toList())));
            System.out.println("People grouped by age: " + nameOfPeopleByAge);
            
        Output:
            People grouped by age: {35=[Greg], 20=[John], 21=[Sara, Jane]}
            
    Let's look at one more combination: let's group the names by their first character and then 
    get the oldest person in each group
    
            Comparator<Person> byAge = Comparator.comparing(Person::getAge)
            Map<Character, Oprional<Person>> oldestPersonOfEachLetter = 
                people.stream()
                      .collect(groupingBy(person -> person.getName().charAt(0),
                           reducing(BinaryOperator.maxBy(byAge))));
                           
            System.out.println("Oldest person of each letter:");
            System.out.println(oldestPersonOfEachLetter);
        
        Output:
        Oldest person of each letter:
        {S=Optional[Sara - 21], G=Optional[Greg - 35], J=Optional[Jane - 21]}

    
        